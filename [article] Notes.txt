https://en.wikipedia.org/wiki/Behavior-driven_development

«если вы следуете TDD, то можете быть 100% уверены, что каждая строчка 
кода была написана благодаря упавшему(ым) тесту(ам)»

behavior-driven development (BDD) is a software development process that emerged 
from test-driven development (TDD).
Behavior-driven development is an extension of test-driven development:[1] development 
that makes use of a simple, domain-specific scripting language. These DSLs (domain-specific language)
 convert structured natural language statements into executable tests. The result is a closer 
relationship to acceptance criteria for a given function and the tests used to validate that functionality.

Test-driven development is a software development methodology which essentially states that for
 each unit of software, a software developer must:

    define a test set for the unit first;
    make the tests fail;
    then implement the unit;
    finally verify that the implementation of the unit makes the tests succeed.

A common risk with software development includes communication breakdowns between 
Developers and Business Stakeholders.[18] BDD uses the specification of desired behavior 
as a ubiquitous language for the project Team members. This is the reason that BDD insists 
on a semi-formal language for behavioral specification: some formality is a requirement 
for being a ubiquitous language.[2] In addition, having such a ubiquitous language creates
 a domain model of specifications, so that specifications may be reasoned about formally.
[19] This model is also the basis for the different BDD-supporting software tools that are 
available.

Most BDD applications use text-based DSLs and specification approaches. However, graphical 
modeling of integration scenarios has also been applied successfully in practice, e.g., 
for testing purposes. [20]

Much like test-driven design practice, behavior-driven development assumes the use of 
specialized support tooling in a project. Inasmuch as BDD is, in many respects, a more
 specific version of TDD, the tooling for BDD is similar to that for TDD, but makes more
 demands on the developer than basic TDD tooling.


    The tooling reads a specification document.
    The tooling directly understands completely formal parts of the ubiquitous language 
(such as the Given keyword in the example above). Based on this, the tool breaks each scenario
 up into meaningful clauses.
    Each individual clause in a scenario is transformed into some sort of parameter for a 
test for the user story. This part requires project-specific work by the software developers.
    The framework then executes the test for each scenario, with the parameters from that scenario.

The bold print is not part of the input; it is included here to show which words are recognized 
as formal language. JBehave recognizes the terms Given (as a precondition which defines the start
 of a scenario), When (as an event trigger) and Then (as a postcondition which must be verified 
as the outcome of the action that follows the trigger).

JBehave then takes these clauses and passes them on to code that is capable of setting a test,
 responding to the event triggers and verifying the outcome. This code must be written by the
 developers in the project team (in Java, because that is the platform JBehave is based on).
 In this case, the code might look like this:

https://vimeo.com/72673788
About BDD in simply words.










