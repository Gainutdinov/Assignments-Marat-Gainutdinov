		Main
-----Introduction Sequence-----
1: Introduction to Git Commits
git commit
git commit

2: Branching in Git
git checkout -b bugFix

3: Merging in Git
git checkout bugFix; git merge master 
git checkout -b bugFix
git commit
git checkout master
git commit
git merge bugFix

4: Rebase Introduction
git checkout -b bugFix
git commit
git checkout master
git commit
git checkout bugFix
git rebase master


-----Ramping Up-----
1: Detach yo' HEAD
git checkout C4

2: Relative Refs (^)
#to moving upward one commit at a time with ^ or number of times with ~<num>
git checkout bugFix
git checkout HEAD^

3: Relative Refs #2 (~)
#relative refs is commonly used to move branches around
#you can directly reassign a branch to a commit with the -f option likne git branch -f HEAD~3
git checkout master
git branch -f master C6
git checkout bugFix
git branch -f bugFix HEAD~3
git checkout C1

or 

git branch -f master C6
git checkout HEAD~1
git branch -f bugFix HEAD~1

4: Reversing Changes in Git
#git reset reverts changes by moving a branch backwards for ex: git reset HEAD~1
#git reset will move a branch backwards as if the commit had never been made
#while git reset works for local branches only it doesn't works with remote repo
#git revert it's like remove current commit but go agead with new commit 
#but do directly reverse changes for ex: git revert HEAD
git reset HEAD^
git checkout pushed
git revert HEAD

-----Moving Work Around-----
1: Cherry-pick Intro
#git cherry-pick <commit1> <commit2> <...>
#It's a very straightforward way of saying that you would like to copy a series 
#of commits below your current location (HEAD)
git cherry-pick C3 C4 C7

2: Interactive Rebase Intro
#all interactive rebase means is using the rebase command with the -i opion
#example git rebase -i HEAD~4
git rebase -i HEAD~4

-----A Mixed Bag-----
1: Grabbing Just 1 Commit
git checkout master
git cherry-pick C4

2: Juggling Commits
#We will re-order the commits so the one we want to change is on top with git rebase -i
#We will commit --amend to make the slight modification
#Then we will re-order the commits back to how they were previously with git rebase -i
#Finally, we will move master to this updated part of the tree to finish the level (via #the method of your choosing)
git rebase -i master #C3 C2
git commit --amend 
git rebase -i master #C2 C3
git checkout master
git branch -f master C3''

3: Juggling Commits #2
# we should use git cherry-pick C2 
git checkout master
git cherry-pick C2
git branch -f master C1
git cherry-pick C2' C3

4: Git Tags
#git tag v1 C1
git tag v1 C2
git tag v0 C1
git checkout C2 or git checkout v0

5: Git Describe
#git describe give you closest tag
#git describe <ref> <tag>_<numCommits>_g<hash>
# for example: git describe master output will be v1_2_gC2
# for example: git describe side output will be v2_1_gC4
git commit

-----Advanced Topics-----
1. Rebasing over 9000 times
git rebase -i master C3
git rebase -i HEAD C6
git rebase -i HEAD C7
git branch -f master C7'
	or
git rebase master bugFix
git rebase bugFix side
git rebase side another
git rebase another master

2: Multiple parents
#via git checkout master^2 we can get to the 2nd parent or
#via git checkout master^1 we can get to the 1st parent
#git checkout HEAD~; git checkout HEAD^2; git checkout HEAD~2 = git checkout HEAD~^2~2 
git checkout HEAD~^2~
git checkout -b bugWork
git checkout master
	or
git branch bugWork master^^2^

3: Branch Spaghetti
git checkout one
git cherry-pick C4 C3 C2
git checkout two
git cherry-pick C5 C4' C3' C2'
git branch -f three C2



		Remote
-----Push & Pull -- Git Remotes!-----
1: Clone Intro
git clone

2: Remote Branches
#<remote name>/<branch name>
#Lets check out a remote branch and see what happens
#git checkout o/master; git commit
#As you can see, git put us into detached HEAD mode and then did not update o/master when #we added a new commit. This is because o/master will only update when the remote updates.
git commit
git checkout o/master #and now we in detached HEAD mode
git commit #still in detached HEAD mode

3: Git Fetchin' (recieve)
#git getch http:// command download the commits that the remote has but are missing from
#our local repo, and...
#updates where our remote branches point (for instance, origin/master)
#BUT fetch doesn't change anything about your local state, it won't update yoru master
#or change anything about how your file system looks right now
git fetch

4: Git Pullin'
#git pull = git fetch + git merge
git pull

5: Faking Teamwork
#git fakeTeamwork command will add in remote repo new commit
#git fakeTeamwork foo 3 will add 3 new commits to the foo branch
git clone
git fakeTeamwork master 2 #fake command!
git commit
git pull

6: Git Pushin'
#push (aka publish), we push our commits to the remote repo
git commit
git commit
git push

7: Diverged History
#git fetch; git rebase o/master; git push 
#git fetch; git merge o/master; git push same thing will happend like in the prevoius #commands
#git pull --rebase; git push  result of the command will be the same
#git pull; git push  the same result
git clone
git fakeTeamwork #fake command!
git commit
git fetch
git rebase o/master
git push 


-----To Origin And Beyond -- Advanced Git Remotes!----- 
1: Push Master!
#in this workflow we combine two things:
#integrating feature branch work onto master, and
#pushing and pulling from the remote
#we use commands: git pull --rebase; git push
git branch -f master C2
git pull --rebase
git push
git branch -f master C4
git pull --rebase
git push
git branch -f master C7
git pull --rebase
git push
    or
reset --forSolution
git fetch
git rebase o/master side1
git rebase side1 side2
git rebase side2 side3
git rebase side3 master
git push

2: Merging with remotes
#Pros: Rebasing makes your commit tree look very clean since everything is in a straight #line
#Cons: Rebasing modifies the (apparent) history of the commit tree
git fetch
git branch -f master C8
git checkout master
git merge side1
git merge side2
git merge side3
git push
    or
git checkout master
git pull
git merge side1
git merge side2
git merge side3
git push

3: Remote Tracking
#git checkout -b foo o/master; git pull
#As you can see, we used the implied merge target of o/master to update the foo branch,
#note how master doesn't get updated
#we just pull the remote master branch to the foo branch
#git checkout -b foo o/master; git commit; git push command will push
# info into the o/master branch (remote)
#another way to set remote tracking on a branch is to simply use the git branch -u option
#run git branch -u o/master foo
#will set the foo branch to track o/master. if foo is currently checked our you can
#even leave it off: git branch -u o/master
#git branch -u o/master foo; git commit; git push

git branch side
git checkout side
git commit
git branch -f side C1
git branch -u o/master side
git pull
git cherry-pick C3
git push
    or
git checkout -b side o/master
git commit
git pull --rebase

4: Git push arguments
#git checkout C0; git push origin master
git push origin foo
git psuh origin master

5: Git push arguments -- Expanded!
#git push origin <source>:<destination>
#remember <source> is any location that git understand
#for ex:git push origin foo^:master
#even we can push to the new remote brance
# via this command git push origin master:newBranch
git push origin foo:master
git push origin master^:foo

6: Fetch arguments
#git fetch origin foo to fetch commits from foo branch
#fetch only download the commits
#so the fetch and push are quite similar, just in opposite directions
#git fetch origin foo~1:bar hence foo~1 is <source> to the bar
#also command in parallel creates bar branch if it doesn't exist
#if there are no arguments it jus downloads all the commits from remote branches
git fetch origin master:foo
git fetch origin foo:master
git checkout foo
git merge master

7: Source of nothing
#what does git push origin :foo it DELETES REMOTE AND LOCAL BRNACH CALLED FOO
#but it only in case if foo branch exist in remote and local repo
#git fetch origin :bar create in new branch in local repo
git push origin :foo
git fetch origin :bar

8: Pull arguments
#command git pull origin foo = git fetch origin foo; git merge o/foo
#command git pull origin bar~1:bugFix = git fetch origin bar~1:bugFix; git merge bugFix
#git pull origin master we download commit onto o/master just as normal. Then we merged #o/master to where we are, regardless of what was currently checked out
#git pull origin master:foo works like master <source> foo <destination>, command create #new branch foo and when just merge foo with bar, but foo branch stand in a same place
git fetch origin master:side
git fetch origin bar:foo
git merge foo
git merge side
    or
git pull origin bar:foo
git pull origin master:side



