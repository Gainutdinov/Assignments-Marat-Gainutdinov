http://learngitbranching.js.org/

we can use: 
            commit
            branch
            checkout
            cherry-pick
            reset
            revert
            rebase
            merge
Ты можешь делиться результатами с друзьями при помощи >export tree и >import tree
Хочешь создать классный уровень? Сделай это при помощи build level или добавь уровень друга при помощи >import level
Команда >show commands покажет все доступные инструкции. Там есть очень полезные, например >undo и >reset
Можно ещё долго рассказывать о коммитах, но для простоты будем считать их полными снимками проекта.
Ветки в Git, как и коммиты, невероятно легковесны. Это просто ссылки на определённый коммит — ничего более. Вот почему многие фанаты Git повторяют мантру делай ветки сразу, делай ветки часто.
git checkout [name] Эта команда перенесёт нас на новую ветку в момент, когда мы ещё не коммитили изменения

Второй способ объединения изменений в ветках - это rebasing. При ребейзе Git по сути копирует набор коммитов и переносит их в другое место.
Несмотря на то, что это звучит достаточно непонятно, преимущество rebase в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете rebase.

Хорошая новость в том, что Git достаточно умён в работе с хешами. Ему нужны лишь первые несколько символов для того, чтобы идентифицировать конкретный коммит.

Для начала рассмотрим оператор каретки (^). Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита. Так что master^ означает "первый предок (origin) ветки master".

Предположим, нужно переместиться на много шагов назад по дереву. Было бы неудобно печатать ^ несколько раз (или несколько десятков раз), так что Git поддерживает также оператор тильда (~).

Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции -f. Например, команда: git branch -f master HEAD~3

git reset отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.

Посмотрим, как это работает: git reset HEAD~1

Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.

Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать git revert. Посмотрим, как это работает: git revert HEAD

Забавно, появился новый коммит. Дело в том, что новый коммит C2' просто содержит изменения, полностью противоположные тем, что сделаны в коммите C2.

После revert можно сделать push и поделиться изменениями с остальными.

"Git Cherry-pick"

Первая из таких команд - это git cherry-pick. Она выглядит вот так:git cherry-pick <Commit1> <Commit2> <...>

Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD). Мы обожаем cherry-pick за то, что в нём очень мало магии и его очень просто понять и применять.

Посмотрим на демонстрацию.

Вот репозиторий, где есть некие изменения в ветке side, которые мы хотим применить и в ветку master. Мы можем сделать это при помощи команды rebase, которую мы уже прошли, но давай посмотрим, как cherry-pick справится с этой задачей: git cherry-pick C2 C4

Git cherry-pick прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши)

Но как быть в случае, когда точно не известно какие коммиты нужны? К счастью, Git позаботился о таких cитуациях! Можно использовать интерактивный rebase для этого - лучший способ отобрать набор коммитов для rebase.

Всё, что нужно для интерактивного rebase - это опция -i

Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.

Для "реального" Git, этот интерфейс означает просто открытие файла в редакторе типа vim. Для этой обучалки, я сделал небольшое диалоговое окно, которое по сути делает то же, что и редактор.

После нажатия на эту кнопку появится окно интерактивного rebase. Переставь несколько коммитов (или удали кое-какие) и посмотри, что получится в итоге: git rebase -i HEAD~4

Надо заставить git копировать только один из коммитов. Это почти как в предыдущем уровне – мы можем использовать уже известные нам команды:
git rebase -i
git cherry-pick
Чтобы достичь желаемого результата.

"Жонглируем коммитами"
Вот ещё одна ситуация, которая часто случается. Есть некоторые изменения (newImage) и другие изменения (caption), которые связаны так, что находятся друг поверх друга в репозитории.

Штука в том, что иногда нужно внести небольшие изменения в более ранний коммит. В таком случае надо немного поменять newImage, несмотря на то, что коммит уже в прошлом!

Преодолеть эти трудности можно следующим образом:

Переставить коммит так, чтобы нужный находился наверху при помощи git rebase -i
Внести изменения при помощи commit --amend
Переставить всё обратно при помощи git rebase -i
И наконец, переместить master на изменённую часть дерева, чтобы закончить уровень.
Это задание можно выполнить несколькими способами (и, гляжу, ты посматриваешь на cherry-picking), но сейчас сосредоточься на вышеописанном методе.

Обрати внимание на итоговое состояние в этом уровне – так как мы дважды перемещаем коммиты, оба они получат по апострофу. Ещё один апостроф добавляется, когда мы делаем commit --amend.

Важно, чтобы совпадало не только дерево коммитов, но и количество апострофов.

Важно помнить, что cherry-pick поместит любой коммит сразу после HEAD (только если этот коммит не является предком HEAD)

Вот небольшое демо для напоминания:

git cherry-pick C2


Такое средство имеется. Git предоставляет нам теги, чья основная задача – ссылаться постоянно на конкретный коммит.

Важно, что после создания они никогда не сменят своего положения, так что можно с лёгкостью сделать checkout конкретного момента в истории изменений

Посмотрим на это на практике.

Создадим тег на C1, который будет нашей версией 1

git tag v1 C1

Готово! Всё просто. Мы назвали тег v1 и заставили его ссылаться на C1 явным образом. Если конкретный коммит не указан, гит пометит тегом HEAD

Теги являются прекрасными ориентирами в истории изменений, поэтому в git есть команда, которая показывает, как далеко текущее состоянии от ближайшего тега. И эта команда называется git describe

Git describe помогает сориентироваться после отката на много коммитов по истории изменений. Такое может случиться, когда вы сделали git bisect или если вы недавно вернулись из отпуска =)

Git describe выглядит примерно так:

git describe <ref>

Где ref — это что-либо, что указывает на конкретный коммит. Если не указать ref, то git будет считать, что указано текущее положение (HEAD).

Вывод команды выглядит примерно так:

<tag>_<numCommits>_g<hash>

Где tag – это ближайший тег в истории изменений, numCommits – это на сколько далеко мы от этого тега, а hash – это хеш коммита, который описывается.

Посмотрим на простой пример. Для дерева, показанного ниже:
git tag v2 C3
Команда git describe master выведет:
v1_2_gC2
Тогда как git describe side выведет:
v2_1_gC4

Но начальство усложняет нашу задачу тем, что желает видеть все коммиты по порядку. Так что коммит С7' должен идти после коммита С6' и так далее.
Если что-то пойдёт не так – не надо стесняться использовать reset, чтобы начать всё с чистого листа. Постарайся сделать как можно меньше манипуляций!

