http://learngitbranching.js.org/
we can use: 
            commit
            branch
            checkout
            cherry-pick
            reset
            revert
            rebase
            merge
Ты можешь делиться результатами с друзьями при помощи >export tree и >import tree
Хочешь создать классный уровень? Сделай это при помощи build level или добавь уровень друга при помощи >import level
Команда >show commands покажет все доступные инструкции. Там есть очень полезные, например >undo и >reset
Можно ещё долго рассказывать о коммитах, но для простоты будем считать их полными снимками проекта.
Ветки в Git, как и коммиты, невероятно легковесны. Это просто ссылки на определённый коммит — ничего более. Вот почему многие фанаты Git повторяют мантру делай ветки сразу, делай ветки часто.
git checkout [name] Эта команда перенесёт нас на новую ветку в момент, когда мы ещё не коммитили изменения

Второй способ объединения изменений в ветках - это rebasing. При ребейзе Git по сути копирует набор коммитов и переносит их в другое место.
Несмотря на то, что это звучит достаточно непонятно, преимущество rebase в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете rebase.

Хорошая новость в том, что Git достаточно умён в работе с хешами. Ему нужны лишь первые несколько символов для того, чтобы идентифицировать конкретный коммит.

Для начала рассмотрим оператор каретки (^). Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита. Так что master^ означает "первый предок (origin) ветки master".

Предположим, нужно переместиться на много шагов назад по дереву. Было бы неудобно печатать ^ несколько раз (или несколько десятков раз), так что Git поддерживает также оператор тильда (~).

Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции -f. Например, команда: git branch -f master HEAD~3

git reset отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.

Посмотрим, как это работает: git reset HEAD~1

Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.

Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать git revert. Посмотрим, как это работает: git revert HEAD

Забавно, появился новый коммит. Дело в том, что новый коммит C2' просто содержит изменения, полностью противоположные тем, что сделаны в коммите C2.

После revert можно сделать push и поделиться изменениями с остальными.

"Git Cherry-pick"

Первая из таких команд - это git cherry-pick. Она выглядит вот так:git cherry-pick <Commit1> <Commit2> <...>

Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD). Мы обожаем cherry-pick за то, что в нём очень мало магии и его очень просто понять и применять.

Посмотрим на демонстрацию.

Вот репозиторий, где есть некие изменения в ветке side, которые мы хотим применить и в ветку master. Мы можем сделать это при помощи команды rebase, которую мы уже прошли, но давай посмотрим, как cherry-pick справится с этой задачей: git cherry-pick C2 C4

Git cherry-pick прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши)

Но как быть в случае, когда точно не известно какие коммиты нужны? К счастью, Git позаботился о таких cитуациях! Можно использовать интерактивный rebase для этого - лучший способ отобрать набор коммитов для rebase.

Всё, что нужно для интерактивного rebase - это опция -i

Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.

Для "реального" Git, этот интерфейс означает просто открытие файла в редакторе типа vim. Для этой обучалки, я сделал небольшое диалоговое окно, которое по сути делает то же, что и редактор.

После нажатия на эту кнопку появится окно интерактивного rebase. Переставь несколько коммитов (или удали кое-какие) и посмотри, что получится в итоге: git rebase -i HEAD~4

Надо заставить git копировать только один из коммитов. Это почти как в предыдущем уровне – мы можем использовать уже известные нам команды:
git rebase -i
git cherry-pick
Чтобы достичь желаемого результата.

"Жонглируем коммитами"
Вот ещё одна ситуация, которая часто случается. Есть некоторые изменения (newImage) и другие изменения (caption), которые связаны так, что находятся друг поверх друга в репозитории.

Штука в том, что иногда нужно внести небольшие изменения в более ранний коммит. В таком случае надо немного поменять newImage, несмотря на то, что коммит уже в прошлом!

Преодолеть эти трудности можно следующим образом:

Переставить коммит так, чтобы нужный находился наверху при помощи git rebase -i
Внести изменения при помощи commit --amend
Переставить всё обратно при помощи git rebase -i
И наконец, переместить master на изменённую часть дерева, чтобы закончить уровень.
Это задание можно выполнить несколькими способами (и, гляжу, ты посматриваешь на cherry-picking), но сейчас сосредоточься на вышеописанном методе.

Обрати внимание на итоговое состояние в этом уровне – так как мы дважды перемещаем коммиты, оба они получат по апострофу. Ещё один апостроф добавляется, когда мы делаем commit --amend.

Важно, чтобы совпадало не только дерево коммитов, но и количество апострофов.

Важно помнить, что cherry-pick поместит любой коммит сразу после HEAD (только если этот коммит не является предком HEAD)

Вот небольшое демо для напоминания:

git cherry-pick C2


Такое средство имеется. Git предоставляет нам теги, чья основная задача – ссылаться постоянно на конкретный коммит.

Важно, что после создания они никогда не сменят своего положения, так что можно с лёгкостью сделать checkout конкретного момента в истории изменений

Посмотрим на это на практике.

Создадим тег на C1, который будет нашей версией 1

git tag v1 C1

Готово! Всё просто. Мы назвали тег v1 и заставили его ссылаться на C1 явным образом. Если конкретный коммит не указан, гит пометит тегом HEAD

Теги являются прекрасными ориентирами в истории изменений, поэтому в git есть команда, которая показывает, как далеко текущее состоянии от ближайшего тега. И эта команда называется git describe

Git describe помогает сориентироваться после отката на много коммитов по истории изменений. Такое может случиться, когда вы сделали git bisect или если вы недавно вернулись из отпуска =)

Git describe выглядит примерно так:

git describe <ref>

Где ref — это что-либо, что указывает на конкретный коммит. Если не указать ref, то git будет считать, что указано текущее положение (HEAD).

Вывод команды выглядит примерно так:

<tag>_<numCommits>_g<hash>

Где tag – это ближайший тег в истории изменений, numCommits – это на сколько далеко мы от этого тега, а hash – это хеш коммита, который описывается.

Посмотрим на простой пример. Для дерева, показанного ниже:
git tag v2 C3
Команда git describe master выведет:
v1_2_gC2
Тогда как git describe side выведет:
v2_1_gC4

Давайте начнём постепенное изучение и взглянем на то, что собой представляет удалённый репозиторий (в нашем представлении).

git clone

Вот так! Теперь у нас есть удалённый репозиторий нашего проекта. Выглядит всё довольно одинаковым за исключением некоторых визуальных различий - в последующих уровнях вы увидите, как мы разделяем работу по этим репозиториям.

Теперь, когда вы уже увидели git clone в действии, давайте углубимся в детали и посмотрим что же на самом деле изменилось.

Во-первых, вы должны были заметить, что у нас в локальном репозитории появилась новая ветка с именем o/master. Такой тип ветки называется удалённой веткой. Поскольку удалённые ветки играют важную и уникальную роль, они обладают рядом специальных свойств.

Удалённые ветки отражают состояние удалённых репозиториев (с того момента, как вы обращались к этим удалённым репозиториям в последний раз). Они позволяют вам отслеживать и видеть разницу между вашими локальными наработками и тем, что было сделано другими участниками - важный шаг, который необходимо делать, прежде чем делиться своими наработками с другими.

Важным свойством удалённых веток является тот факт, что когда вы извлекаете их, вы отделяете (detaching) HEAD. Git делает это потому, что вы не можете работать непосредственно в этих ветках; сперва вам необходимо сделать наработки где-либо, а уж затем делиться ими с удалёнными репозиториями (после чего ваши удалённые ветки будут обновлены).

Вы, наверное, догадались, что первый символ o/ в названии ветки служит для обозначения именно удалённых веток. Да. Удалённые ветки также имеют (обязательное) правило именования - они отображаются в формате:

<удалённый репозиторий>/<имя ветки>
Следовательно, если вы взглянете на имя ветки o/master, то здесь master - это имя ветки, а o - это имя удалённого репозитория.

Большинство разработчиков именуют свои главные удалённые репозитории не как o, а как origin. Также общепринятым является именование удалённого репозитория как origin, когда вы клонируете репозиторий командой git clone.

К сожалению, полное имя origin не помещается на элементах дизайна наших уроков, поэтому мы используем краткое o :( Просто помните, когда вы пользуетесь git в реальном проекте, ваш удалённый репозиторий скорее всего будет называться origin!

Давайте извлечём (check out) удалённую ветку и посмотрим что произойдёт
git checkout o/master; git commit
Как вы можете видеть, git отделил (detached) HEAD и не обновил o/master, когда мы добавили новый коммит. Всё потому, что o/master обновится тогда и только тогда, когда обновится сам удалённый репозиторий.

В этом уроке вы научитесь тому, как извлекать данные из удалённого репозитория - и для этого у нас есть соответствующая команда git fetch.

Прежде чем углубляться в детали команды git fetch, давайте взглянем на её визуализацию в действии! Здесь у нас имеется удалённый репозиторий, который содержит в себе два коммита, отсутствующих в нашем локальном репозитории.

git fetch

Вот и всё! Коммиты C2 и C3 были успешно скачаны в наш локальный репозиторий, и наша удалённая ветка o/master отобразила эти изменения соответствующим образом.

Что делает fetch
git fetch выполняет две и только две основные операции. А именно:
связывается с указанным удалённым репозиторием и забирает все те данные проекта, которых у вас ещё нет, при этом...
у вас должны появиться ссылки на все ветки из этого удалённого репозитория (например, o/master)
Фактически, git fetch синхронизирует локальное представление удалённых репозиториев с тем, что является актуальным на текущий момент времени.
Насколько вы помните, в предыдущем уроке мы сказали, что удалённые ветки отображают состояние удалённых репозиториев на тот момент когда вы 'общались' с ними в последний раз. git fetch является тем механизмом, который даёт вам возможность общаться с удалёнными репозиториями! Надеюсь, что связь между удалёнными ветками и командой git fetch теперь прояснилась.
git fetch обычно 'общается' с удалёнными репозиториями посредством Интернета (через такие протоколы, как http:// или git://).

Чего fetch не делает
Важно отметить, что команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент.
Важно это помнить и понимать, потому что многие разработчики думают, что, запустив команду git fetch, они приведут всю свою локальную работу к такому же виду, как и на удалённом репозитории. Команда всего лишь скачивает все необходимые данные, но вам потребуется вручную слить эти данные с вашими, когда вы будете готовы. В следующих уроках мы научимся это делать :D
Одним словом, вы можете относиться к git fetch как к процедуре скачивания.

Теперь, когда мы познакомились с тем, как извлекать данные из удалённого репозитория с помощью git fetch, давайте обновим нашу работу, чтобы отобразить все эти изменения!
Существует множество вариантов решений - как только у вас имеется локальный коммит, вы можете соединить его с другой веткой. Это значит, вы можете выполнить одну из команд:
git cherry-pick o/master
git rebase o/master
git merge o/master
и т.д.
Процедура скачивания (fetching) изменений с удалённой ветки и объединения (merging) настолько частая и распространённая, что git предоставляет вместо двух команд - одну! Эта команда - git pull.

Давайте рассмотрим, как fetch и merge выполняются последовательно
git fetch; git merge o/master
Опа - мы скачали C3 с помощью команды fetch и затем объединяем эти наработки с помощью git merge o/master. Теперь наша ветка master отображает изменения с удалённого репозитория (в данном случае — с репозитория origin)

Что же произойдёт, если вместо этих команд мы воспользуемся git pull?
git pull
Абсолютно то же самое! Нужно чётко понимать, что git pull существенно уменьшает вашу рутинную работу, если бы вы использовали git fetch и последующее слияние (merging) скаченной ветки.

Мы изучим детали команды git pull чуть позже (включая опции и аргументы вызова команды), а пока что давайте просто попробуем эту команду.
Помните, вы также можете выполнить этот уровень с помощью команд fetch и merge, но нужно ли делать так, когда можно воспользоваться всего лишь одной командой ? :P

Поведение команды fakeTeamwork по умолчанию заключается в том, чтобы просто "инициировать" коммит на master-е
git fakeTeamwork
Ну вот - удалённый репозиторий был изменён при помощи добавления нового коммита, и мы ещё не скачали этот коммит, потому что не запустили команду git fetch.

В данной команде вам доступна возможность указать ветку и количество добавляемых коммитов
git fakeTeamwork foo 3
С помощью одной лишь команды мы симулируем добавление трёх коммитов в ветку foo на удалённом репозитории



git clone
git fakeTeamwork
git pull



